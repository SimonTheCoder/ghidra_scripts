#Script to decode a ARM64 ESR(Exception Syndrome Register) value to human readable info.
#ref: https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-
#By SimonTheCoder
#@category SimonTheCoder

DEBUG = True

EC_dict = dict()
EC_dict[	0b000000	]="	Unknown reason.	"
EC_dict[	0b000001	]="	Trapped WF* instruction execution. \nConditional WF* instructions that fail their condition code check do not cause an exception."
EC_dict[	0b000011	]="	Trapped MCR or MRC access with (coproc==0b1111) that is not reported using EC 0b000000.	"
EC_dict[	0b000100	]="	Trapped MCRR or MRRC access with (coproc==0b1111) that is not reported using EC 0b000000.	"
EC_dict[	0b000101	]="	Trapped MCR or MRC access with (coproc==0b1110).	"
EC_dict[	0b000110	]="	Trapped LDC or STC access.	\nThe only architected uses of these instruction are:\nAn STC to write data to memory from DBGDTRRXint.\nAn LDC to read data from memory to DBGDTRTXint.	"
EC_dict[	0b000111	]="	Access to SVE, Advanced SIMD or floating-point functionality trapped by CPACR_EL1.FPEN, CPTR_EL2.FPEN, CPTR_EL2.TFP, or CPTR_EL3.TFP control.	\nExcludes exceptions resulting from CPACR_EL1 when the value of HCR_EL2.TGE is 1, or because SVE or Advanced SIMD and floating-point are not implemented. These are reported with EC value 0b000000 as described in 'The EC used to report an exception routed to EL2 because HCR_EL2.TGE is 1'."
EC_dict[	0b001010	]="	Trapped execution of an LD64B, ST64B, ST64BV, or ST64BV0 instruction.	"
EC_dict[	0b001100	]="	Trapped MRRC access with (coproc==0b1110).	"
EC_dict[	0b001101	]="	Branch Target Exception.	"
EC_dict[	0b001110	]="	Illegal Execution state.	"
EC_dict[	0b010001	]="	SVC instruction execution in AArch32 state.	"
EC_dict[	0b010101	]="	SVC instruction execution in AArch64 state.	"
EC_dict[	0b011000	]="	Trapped MSR, MRS or System instruction execution in AArch64 state, that is not reported using EC 0b000000, 0b000001, or 0b000111.	\nThis includes all instructions that cause exceptions that are part of the encoding space defined in 'System instruction class encoding overview', except for those exceptions reported using EC values 0b000000, 0b000001, or 0b000111.	"
EC_dict[	0b011001	]="	Access to SVE functionality trapped as a result of CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ, that is not reported using EC 0b000000.	"
EC_dict[	0b011100	]="	Exception from a Pointer Authentication instruction authentication failure	"
EC_dict[	0b100000	]="	Instruction Abort from a lower Exception level.\nUsed for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.	"
EC_dict[	0b100001	]="	Instruction Abort taken without a change in Exception level.	\nUsed for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions."
EC_dict[	0b100010	]="	PC alignment fault exception.	"
EC_dict[	0b100100	]="	Data Abort from a lower Exception level.	\nUsed for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions."
EC_dict[	0b100101	]="	Data Abort taken without a change in Exception level.	\nUsed for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions."
EC_dict[	0b100110	]="	SP alignment fault exception.	"
EC_dict[	0b101000	]="	Trapped floating-point exception taken from AArch32 state.	\nThis EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is IMPLEMENTATION DEFINED."
EC_dict[	0b101100	]="	Trapped floating-point exception taken from AArch64 state.	\nThis EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is IMPLEMENTATION DEFINED."
EC_dict[	0b101111	]="	SError interrupt.	"
EC_dict[	0b110000	]="	Breakpoint exception from a lower Exception level.	"
EC_dict[	0b110001	]="	Breakpoint exception taken without a change in Exception level.	"
EC_dict[	0b110010	]="	Software Step exception from a lower Exception level.	"
EC_dict[	0b110011	]="	Software Step exception taken without a change in Exception level.	"
EC_dict[	0b110100	]="	Watchpoint exception from a lower Exception level.	"
EC_dict[	0b110101	]="	Watchpoint exception taken without a change in Exception level.	"
EC_dict[	0b111000	]="	BKPT instruction execution in AArch32 state.	"
EC_dict[	0b111100	]="	BRK instruction execution in AArch64 state.	"

IL_dict = dict()
IL_dict[0b0] = "16-bit instruction trapped."
IL_dict[0b1] = """32-bit instruction trapped. This value is also used when the exception is one of the following:

    An SError interrupt.

    An Instruction Abort exception.

    A PC alignment fault exception.

    An SP alignment fault exception.

    A Data Abort exception for which the value of the ISV bit is 0.

    An Illegal Execution state exception.

    Any debug exception except for Breakpoint instruction exceptions. For Breakpoint instruction exceptions, this bit has its standard meaning:

        0b0: 16-bit T32 BKPT instruction.

        0b1: 32-bit A32 BKPT instruction or A64 BRK instruction. 

    An exception reported using EC value 0b000000. """

ISS_dict = dict()

class Todo_dict(dict):
    def __getitem__(self, k):
        return "Still in DEV..."

class Unknown_dict(dict):
    def __getitem__(self, k):
        return "Reason Unknown."


#ISS encoding for exceptions with an unknown reason
ISS_dict[0b000000] = Unknown_dict()

ISS_dict[	0b000001	]=Todo_dict()
ISS_dict[	0b000011	]=Todo_dict()
ISS_dict[	0b000100	]=Todo_dict()
ISS_dict[	0b000101	]=Todo_dict()
ISS_dict[	0b000110	]=Todo_dict()
ISS_dict[	0b000111	]=Todo_dict()
ISS_dict[	0b001010	]=Todo_dict()
ISS_dict[	0b001100	]=Todo_dict()
ISS_dict[	0b001101	]=Todo_dict()
ISS_dict[	0b001110	]=Todo_dict()
ISS_dict[	0b010001	]=Todo_dict()
ISS_dict[	0b010101	]=Todo_dict()
ISS_dict[	0b011000	]=Todo_dict()
ISS_dict[	0b011001	]=Todo_dict()
ISS_dict[	0b011100	]=Todo_dict()
ISS_dict[	0b100000	]=Todo_dict()
ISS_dict[	0b100001	]=Todo_dict()
ISS_dict[	0b100010	]=Todo_dict()
ISS_dict[	0b100100	]=Todo_dict()
ISS_dict[	0b100101	]=Todo_dict()
ISS_dict[	0b100110	]=Todo_dict()
ISS_dict[	0b101000	]=Todo_dict()
ISS_dict[	0b101100	]=Todo_dict()
ISS_dict[	0b101111	]=Todo_dict()
ISS_dict[	0b110000	]=Todo_dict()
ISS_dict[	0b110001	]=Todo_dict()
ISS_dict[	0b110010	]=Todo_dict()
ISS_dict[	0b110011	]=Todo_dict()
ISS_dict[	0b110100	]=Todo_dict()
ISS_dict[	0b110101	]=Todo_dict()
ISS_dict[	0b111000	]=Todo_dict()
ISS_dict[	0b111100	]=Todo_dict()


def pick_value(value,high,low):
    if high < low:
        temp = high
        high = low
        low = high
    return (value & int('1'*(high-low+1),2)<<low) >> low

ESR_value = askInt("Input ESR value","ESR value(hex need '0x' prefix):")
if ESR_value is None or ESR_value == 0:
    if DEBUG:
        #for debug only
        ESR_value = 0x96000061
    else:
        #bad value 
        popup("Please input a valid ESR value!")
        exit(1)
#[63:37] bit RES0 in ARM v8
ESR_value = ESR_value & ((1<<37) - 1)

#ISS2, bits [36:32]
ISS2 = pick_value(ESR_value, 36, 32)

#EC, bits [31:26]
EC = pick_value(ESR_value, 31, 26)

#IL, bit [25]
IL = pick_value(ESR_value, 25, 25)

#ISS, bits [24:0]
ISS = pick_value(ESR_value, 24, 0)


result = "ESR:0x%x\n" % (ESR_value)
result = result + "\n-------------------------------\n"
result = result + "EC: 0x%x\nMeaning:\n%s\n\n" % (EC,EC_dict[EC])
result = result + "\n-------------------------------\n"
result = result + "IL: 0x%x\nMeaning:\n%s\n\n" % (IL,IL_dict[IL])
result = result + "\n-------------------------------\n"
result = result + "ISS: 0x%x\nMeaning:\n%s\n\n" % (ISS,"Please ref: https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-")

popup(result)