#Script to decode a ARM64 ESR(Exception Syndrome Register) value to human readable info.
#ref: https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-
#By SimonTheCoder
#@category SimonTheCoder

DEBUG = True

EC_dict = dict()
EC_dict[	0b000000	]="	Unknown reason.	"
EC_dict[	0b000001	]="	Trapped WF* instruction execution. \nConditional WF* instructions that fail their condition code check do not cause an exception."
EC_dict[	0b000011	]="	Trapped MCR or MRC access with (coproc==0b1111) that is not reported using EC 0b000000.	"
EC_dict[	0b000100	]="	Trapped MCRR or MRRC access with (coproc==0b1111) that is not reported using EC 0b000000.	"
EC_dict[	0b000101	]="	Trapped MCR or MRC access with (coproc==0b1110).	"
EC_dict[	0b000110	]="	Trapped LDC or STC access.	\nThe only architected uses of these instruction are:\nAn STC to write data to memory from DBGDTRRXint.\nAn LDC to read data from memory to DBGDTRTXint.	"
EC_dict[	0b000111	]="	Access to SVE, Advanced SIMD or floating-point functionality trapped by CPACR_EL1.FPEN, CPTR_EL2.FPEN, CPTR_EL2.TFP, or CPTR_EL3.TFP control.	\nExcludes exceptions resulting from CPACR_EL1 when the value of HCR_EL2.TGE is 1, or because SVE or Advanced SIMD and floating-point are not implemented. These are reported with EC value 0b000000 as described in 'The EC used to report an exception routed to EL2 because HCR_EL2.TGE is 1'."
EC_dict[	0b001010	]="	Trapped execution of an LD64B, ST64B, ST64BV, or ST64BV0 instruction.	"
EC_dict[	0b001100	]="	Trapped MRRC access with (coproc==0b1110).	"
EC_dict[	0b001101	]="	Branch Target Exception.	"
EC_dict[	0b001110	]="	Illegal Execution state.	"
EC_dict[	0b010001	]="	SVC instruction execution in AArch32 state.	"
EC_dict[	0b010101	]="	SVC instruction execution in AArch64 state.	"
EC_dict[	0b011000	]="	Trapped MSR, MRS or System instruction execution in AArch64 state, that is not reported using EC 0b000000, 0b000001, or 0b000111.	\nThis includes all instructions that cause exceptions that are part of the encoding space defined in 'System instruction class encoding overview', except for those exceptions reported using EC values 0b000000, 0b000001, or 0b000111.	"
EC_dict[	0b011001	]="	Access to SVE functionality trapped as a result of CPACR_EL1.ZEN, CPTR_EL2.ZEN, CPTR_EL2.TZ, or CPTR_EL3.EZ, that is not reported using EC 0b000000.	"
EC_dict[	0b011100	]="	Exception from a Pointer Authentication instruction authentication failure	"
EC_dict[	0b100000	]="	Instruction Abort from a lower Exception level.\nUsed for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions.	"
EC_dict[	0b100001	]="	Instruction Abort taken without a change in Exception level.	\nUsed for MMU faults generated by instruction accesses and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions."
EC_dict[	0b100010	]="	PC alignment fault exception.	"
EC_dict[	0b100100	]="	Data Abort from a lower Exception level.	\nUsed for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions."
EC_dict[	0b100101	]="	Data Abort taken without a change in Exception level.	\nUsed for MMU faults generated by data accesses, alignment faults other than those caused by Stack Pointer misalignment, and synchronous External aborts, including synchronous parity or ECC errors. Not used for debug-related exceptions."
EC_dict[	0b100110	]="	SP alignment fault exception.	"
EC_dict[	0b101000	]="	Trapped floating-point exception taken from AArch32 state.	\nThis EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is IMPLEMENTATION DEFINED."
EC_dict[	0b101100	]="	Trapped floating-point exception taken from AArch64 state.	\nThis EC value is valid if the implementation supports trapping of floating-point exceptions, otherwise it is reserved. Whether a floating-point implementation supports trapping of floating-point exceptions is IMPLEMENTATION DEFINED."
EC_dict[	0b101111	]="	SError interrupt.	"
EC_dict[	0b110000	]="	Breakpoint exception from a lower Exception level.	"
EC_dict[	0b110001	]="	Breakpoint exception taken without a change in Exception level.	"
EC_dict[	0b110010	]="	Software Step exception from a lower Exception level.	"
EC_dict[	0b110011	]="	Software Step exception taken without a change in Exception level.	"
EC_dict[	0b110100	]="	Watchpoint exception from a lower Exception level.	"
EC_dict[	0b110101	]="	Watchpoint exception taken without a change in Exception level.	"
EC_dict[	0b111000	]="	BKPT instruction execution in AArch32 state.	"
EC_dict[	0b111100	]="	BRK instruction execution in AArch64 state.	"

IL_dict = dict()
IL_dict[0b0] = "16-bit instruction trapped."
IL_dict[0b1] = """32-bit instruction trapped. This value is also used when the exception is one of the following:

    An SError interrupt.

    An Instruction Abort exception.

    A PC alignment fault exception.

    An SP alignment fault exception.

    A Data Abort exception for which the value of the ISV bit is 0.

    An Illegal Execution state exception.

    Any debug exception except for Breakpoint instruction exceptions. For Breakpoint instruction exceptions, this bit has its standard meaning:

        0b0: 16-bit T32 BKPT instruction.

        0b1: 32-bit A32 BKPT instruction or A64 BRK instruction. 

    An exception reported using EC value 0b000000. """

DFSC_dict = dict()
DFSC_dict[	0b000000	]="	Address size fault, level 0 of translation or translation table base register.	"    #	    
DFSC_dict[	0b000001	]="	Address size fault, level 1.	"    #	    
DFSC_dict[	0b000010	]="	Address size fault, level 2.	"    #	    
DFSC_dict[	0b000011	]="	Address size fault, level 3.	"    #	    
DFSC_dict[	0b000100	]="	Translation fault, level 0.	"    #	    
DFSC_dict[	0b000101	]="	Translation fault, level 1.	"    #	    
DFSC_dict[	0b000110	]="	Translation fault, level 2.	"    #	    
DFSC_dict[	0b000111	]="	Translation fault, level 3.	"    #	    
DFSC_dict[	0b001001	]="	Access flag fault, level 1.	"    #	    
DFSC_dict[	0b001010	]="	Access flag fault, level 2.	"    #	    
DFSC_dict[	0b001011	]="	Access flag fault, level 3.	"    #	    
DFSC_dict[	0b001000	]="	Access flag fault, level 0.	"    #	When FEAT_LPA2 is implemented
DFSC_dict[	0b001100	]="	Permission fault, level 0.	"    #	When FEAT_LPA2 is implemented
DFSC_dict[	0b001101	]="	Permission fault, level 1.	"    #	    
DFSC_dict[	0b001110	]="	Permission fault, level 2.	"    #	    
DFSC_dict[	0b001111	]="	Permission fault, level 3.	"    #	    
DFSC_dict[	0b010000	]="	Synchronous External abort, not on translation table walk or hardware update of translation table.	"    #	    
DFSC_dict[	0b010001	]="	Synchronous Tag Check Fault.	"    #	When FEAT_MTE2 is implemented
DFSC_dict[	0b010011	]="	Synchronous External abort on translation table walk or hardware update of translation table, level -1.	"    #	When FEAT_LPA2 is implemented
DFSC_dict[	0b010100	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 0.	"    #	    
DFSC_dict[	0b010101	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 1.	"    #	    
DFSC_dict[	0b010110	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 2.	"    #	    
DFSC_dict[	0b010111	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 3.	"    #	    
DFSC_dict[	0b011000	]="	Synchronous parity or ECC error on memory access, not on translation table walk.	"    #	When FEAT_RAS is not implemented
DFSC_dict[	0b011011	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.	"    #	When FEAT_LPA2 is implemented and FEAT_RAS is not implemented
DFSC_dict[	0b011100	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.	"    #	When FEAT_RAS is not implemented
DFSC_dict[	0b011101	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.	"    #	When FEAT_RAS is not implemented
DFSC_dict[	0b011110	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.	"    #	When FEAT_RAS is not implemented
DFSC_dict[	0b011111	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.	"    #	When FEAT_RAS is not implemented
DFSC_dict[	0b100001	]="	Alignment fault.	"    #	    
DFSC_dict[	0b101001	]="	Address size fault, level -1.	"    #	When FEAT_LPA2 is implemented
DFSC_dict[	0b101011	]="	Translation fault, level -1.	"    #	When FEAT_LPA2 is implemented
DFSC_dict[	0b110000	]="	TLB conflict abort.	"    #	    
DFSC_dict[	0b110001	]="	Unsupported atomic hardware update fault.	"    #	When FEAT_HAFDBS is implemented
DFSC_dict[	0b110100	]="	IMPLEMENTATION DEFINED fault (Lockdown).	"    #	    
DFSC_dict[	0b110101	]="	IMPLEMENTATION DEFINED fault (Unsupported Exclusive or Atomic access).	"    #	    

IFSC_dict = dict()
IFSC_dict[	0b000000	]="	Address size fault, level 0 of translation or translation table base register.	"    #	    
IFSC_dict[	0b000001	]="	Address size fault, level 1.	"    #	    
IFSC_dict[	0b000010	]="	Address size fault, level 2.	"    #	    
IFSC_dict[	0b000011	]="	Address size fault, level 3.	"    #	    
IFSC_dict[	0b000100	]="	Translation fault, level 0.	"    #	    
IFSC_dict[	0b000101	]="	Translation fault, level 1.	"    #	    
IFSC_dict[	0b000110	]="	Translation fault, level 2.	"    #	    
IFSC_dict[	0b000111	]="	Translation fault, level 3.	"    #	    
IFSC_dict[	0b001001	]="	Access flag fault, level 1.	"    #	    
IFSC_dict[	0b001010	]="	Access flag fault, level 2.	"    #	    
IFSC_dict[	0b001011	]="	Access flag fault, level 3.	"    #	    
IFSC_dict[	0b001000	]="	Access flag fault, level 0.	"    #	When FEAT_LPA2 is implemented
IFSC_dict[	0b001100	]="	Permission fault, level 0.	"    #	When FEAT_LPA2 is implemented
IFSC_dict[	0b001101	]="	Permission fault, level 1.	"    #	    
IFSC_dict[	0b001110	]="	Permission fault, level 2.	"    #	    
IFSC_dict[	0b001111	]="	Permission fault, level 3.	"    #	    
IFSC_dict[	0b010000	]="	Synchronous External abort, not on translation table walk or hardware update of translation table.	"    #	    
IFSC_dict[	0b010011	]="	Synchronous External abort on translation table walk or hardware update of translation table, level -1.	"    #	When FEAT_LPA2 is implemented
IFSC_dict[	0b010100	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 0.	"    #	    
IFSC_dict[	0b010101	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 1.	"    #	    
IFSC_dict[	0b010110	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 2.	"    #	    
IFSC_dict[	0b010111	]="	Synchronous External abort on translation table walk or hardware update of translation table, level 3.	"    #	    
IFSC_dict[	0b011000	]="	Synchronous parity or ECC error on memory access, not on translation table walk.	"    #	When FEAT_RAS is not implemented
IFSC_dict[	0b011011	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level -1.	"    #	When FEAT_LPA2 is implemented and FEAT_RAS is not implemented
IFSC_dict[	0b011100	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 0.	"    #	When FEAT_RAS is not implemented
IFSC_dict[	0b011101	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 1.	"    #	When FEAT_RAS is not implemented
IFSC_dict[	0b011110	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 2.	"    #	When FEAT_RAS is not implemented
IFSC_dict[	0b011111	]="	Synchronous parity or ECC error on memory access on translation table walk or hardware update of translation table, level 3.	"    #	When FEAT_RAS is not implemented
IFSC_dict[	0b101001	]="	Address size fault, level -1.	"    #	When FEAT_LPA2 is implemented
IFSC_dict[	0b101011	]="	Translation fault, level -1.	"    #	When FEAT_LPA2 is implemented
IFSC_dict[	0b110000	]="	TLB conflict abort.	"    #	    
IFSC_dict[	0b110001	]="	Unsupported atomic hardware update fault.	"    #	When FEAT_HAFDBS is implemented


ISS_dict = dict()

class Todo_dict(dict):
    def __getitem__(self, k):
        bin_str = bin(k)[2:]
        bin_str = '0'*(37 -len(bin_str)) + bin_str
        result = ""
        capt = ""
        for i in range(36,-1,-1):
            capt = capt + "%02d  " % i
        tabl = ""
        for i in bin_str:
            tabl = tabl + " %s  " % i
           
        return capt+"\n"+tabl+"\nPlease ref: https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-"

class Unknown_dict(dict):
    def __getitem__(self, k):
        return "Reason Unknown."

class Data_abort_dict(dict):
    def __getitem__(self, k):
        result = "Data abort ISS:\n\n"
        
        ISV = pick_value(k,24,24)
        result = result + "ISV: %s    >>> %s\n" % (bin(ISV), ["No valid instruction syndrome. ISS[23:14] are RES0.","ISS[23:14] hold a valid instruction syndrome."][ISV]) 

        CM = pick_value(k,8,8)
        result = result + "CM: %s    >>> %s\n" % (bin(CM), ["Nothing to do with cache.","Caused by cache maintenance."][CM])

        WnR = pick_value(k,6,6)
        result = result + "WnR: %s    >>> %s\n" % (bin(WnR), ["Caused by reading.","Caused by writing."][WnR])

        DFSC = pick_value(k,5,0)
        result = result + "DFSC: %s    >>> %s\n" % (bin(DFSC), DFSC_dict[DFSC])
        return result

class Inst_abort_dict(dict):
    def __getitem__(self, k):
        result = ""

        FnV = pick_value(k,10,10)
        result = result + "FnV: %s    >>> %s\n" % (bin(FnV), ["FAR is valid.","FAR is not valid, and holds an UNKNOWN value."][FnV])

        EA = pick_value(k,9,9)
        if EA != 0:
            result = result + "EA(External abort type): %s (%s)   \n" % (bin(EA),hex(EA))

        IFSC = pick_value(k,5,0)
        result = result + "IFSC: %s    >>> %s\n" % (bin(IFSC), IFSC_dict[IFSC])
        return result

#ISS encoding for exceptions with an unknown reason
ISS_dict[0b000000] = Unknown_dict()

ISS_dict[	0b000001	]=Todo_dict()
ISS_dict[	0b000011	]=Todo_dict()
ISS_dict[	0b000100	]=Todo_dict()
ISS_dict[	0b000101	]=Todo_dict()
ISS_dict[	0b000110	]=Todo_dict()
ISS_dict[	0b000111	]=Todo_dict()
ISS_dict[	0b001010	]=Todo_dict()
ISS_dict[	0b001100	]=Todo_dict()
ISS_dict[	0b001101	]=Todo_dict()
ISS_dict[	0b001110	]=Todo_dict()
ISS_dict[	0b010001	]=Todo_dict()
ISS_dict[	0b010101	]=Todo_dict()
ISS_dict[	0b011000	]=Todo_dict()
ISS_dict[	0b011001	]=Todo_dict()
ISS_dict[	0b011100	]=Todo_dict()
ISS_dict[	0b100000	]=Inst_abort_dict()
ISS_dict[	0b100001	]=Inst_abort_dict()
ISS_dict[	0b100010	]=Todo_dict()
ISS_dict[	0b100100	]=Data_abort_dict()
ISS_dict[	0b100101	]=Data_abort_dict()
ISS_dict[	0b100110	]=Todo_dict()
ISS_dict[	0b101000	]=Todo_dict()
ISS_dict[	0b101100	]=Todo_dict()
ISS_dict[	0b101111	]=Todo_dict()
ISS_dict[	0b110000	]=Todo_dict()
ISS_dict[	0b110001	]=Todo_dict()
ISS_dict[	0b110010	]=Todo_dict()
ISS_dict[	0b110011	]=Todo_dict()
ISS_dict[	0b110100	]=Todo_dict()
ISS_dict[	0b110101	]=Todo_dict()
ISS_dict[	0b111000	]=Todo_dict()
ISS_dict[	0b111100	]=Todo_dict()


def pick_value(value,high,low):
    if high < low:
        temp = high
        high = low
        low = high
    return (value & int('1'*(high-low+1),2)<<low) >> low
ESR_value = 0
if 'askInt' in vars():
    ESR_value = askInt("Input ESR value","ESR value(hex need '0x' prefix):")
else:
    import sys
    if len(sys.argv) != 2:
        print("usage:\npython3 %s 0x????????" % sys.argv[0])
        exit(1)
    ESR_value = int(sys.argv[1] , 16)

if ESR_value is None or ESR_value == 0:
    if DEBUG:
        #for debug only
        #data abort
        ESR_value = 0x96000061

        #inst abort
        #ESR_value = 0x86000010
    else:
        #bad value 
        popup("Please input a valid ESR value!")
        exit(1)
#[63:37] bit RES0 in ARM v8
ESR_value = ESR_value & ((1<<37) - 1)

#ISS2, bits [36:32]
ISS2 = pick_value(ESR_value, 36, 32)

#EC, bits [31:26]
EC = pick_value(ESR_value, 31, 26)

#IL, bit [25]
IL = pick_value(ESR_value, 25, 25)

#ISS, bits [24:0]
ISS = pick_value(ESR_value, 24, 0)


result = "ESR:0x%x\n" % (ESR_value)
result = result + "\n-------------------------------\n"
result = result + "EC: 0x%x\nMeaning:\n%s\n\n" % (EC,EC_dict[EC])
result = result + "\n-------------------------------\n"
result = result + "IL: 0x%x\nMeaning:\n%s\n\n" % (IL,IL_dict[IL])
result = result + "\n-------------------------------\n"
#result = result + "ISS: 0x%x\nMeaning:\n%s\n\n" % (ISS,"Please ref: https://developer.arm.com/documentation/ddi0595/2020-12/AArch64-Registers/ESR-EL1--Exception-Syndrome-Register--EL1-")
result = result + "ISS: 0x%x\nMeaning:\n%s\n\n" % (ISS, ISS_dict[EC][ESR_value])

if 'popup' in vars():
    popup(result)
else:
    print(result) 